{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Each library have their own link to get the module.</li> <li>if you have any bugs or feedback please send me a message to my discord : .d_0010</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>RobloxProfile</li> <li>Github</li> </ul>"},{"location":"Utils/ASCII/","title":"ASCII","text":""},{"location":"Utils/ASCII/#getting-started","title":"Getting Started","text":""},{"location":"Utils/ASCII/#module-ascii","title":"Module : ASCII","text":"<p>On this page you will learn how to use ASCII module Please read the documentation entirely if you want to really use it for your projects</p> Note <p>This module might be difficult to understand if you dont know how to work with buffer.</p>"},{"location":"Utils/ASCII/#basic","title":"Basic","text":"<p>Let's convert a string into a ASCII Formula</p> Basic <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal HelloASCII = ASCII.StrASCII(\"Hello World\")\nprint(HelloASCII) --&gt; {72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33}\n</code></pre> <p>StrASCII only accept string as a argument and valid ASCII Character and return a array of number representing each character in the ASCII Formula</p> <p>You can also convert an array of numbers represented in ASCII Formula. for exemple lets the result in the last back to a string.</p> ASCII to String <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal HelloASCII = ASCII.ASCIIStr({72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33})\nprint(HelloASCII) --&gt; \"Hello World\"\n</code></pre> <p>now the array has been converted back to a string.</p> <p>In this module you are also be able to convert number to a binary buffer and redo the convertion of that .</p>"},{"location":"Utils/ASCII/#binary","title":"Binary","text":"Number to BinaryBinary to Number <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal bin = ASCII.BinaryNumber(10) --&gt; buffer (each bits contain the bits binary representation) e.g (1010)\nprint(bin) --&gt; buffer size = 4\n</code></pre> <p>First lets do the same has the first exemple about binary</p> <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal bin = ASCII.BinaryNumber(10) --&gt; buffer (each bits contain the bits binary representation) e.g (1010)\nprint(bin) --&gt; buffer size = 4\n\n-- now lets redo the convertion of the binary result\n\nprint(ASCII.BinaryToNumber(bin)) -- 10\n</code></pre> <p>For more complex exemple of binary convertion etc please Advanced Binary tab</p>"},{"location":"Utils/ASCII/#advanced-binary","title":"Advanced Binary","text":"<p>while converting number when calling BinaryNumber into a binary buffer you are also able to pass an array of number and it will return an  array of buffer that each buffer contain the converted number</p> Numbers to Binary Buffers <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal bin = ASCII.BinaryNumber({10,15}) --&gt; buffer (each bits contain the bits binary representation) e.g (1010)\nprint(bin) --&gt; {[1] = buffer,[2] = buffer}\n\n--[[\n    for more exemple the first buffer contain the binary representation of 10 and the other one of 15\n]]\n</code></pre> <p>You can also convert the array of buffer into a number</p> Binary Buffers to Number <pre><code>local ASCII = require(somewhere.ASCII)\n\nlocal bin = ASCII.BinaryNumber({10,15}) --&gt; buffer (each bits contain the bits binary representation) e.g (1010)\nprint(bin) --&gt; {[1] = buffer,[2] = buffer}\n\n--[[\n    for more exemple the first buffer contain the binary representation of 10 and the other one of 15\n]]\n\n-- now lets convert all buffer into a number\n\nprint(ASCII.BinaryToNumber(bin)) -- (e.g ASCII.BinaryToNumber({[1] = buffer,[2] = buffer}))\n--[[\n    the output will display 175 cause all buffer will be merged (e.g [1010][1111])\n    if you want to pass an array of buffer to converting them back into a number  i recommend you to please do a for loop and call BinaryToNumber with each buffer inside the loop.\n]]\n</code></pre>"},{"location":"Utils/Buffer/","title":"Buffer","text":""},{"location":"Utils/Buffer/#getting-started","title":"Getting Started","text":""},{"location":"Utils/Buffer/#module-buffer","title":"Module : Buffer","text":"<p>Overview</p> <p>The Buffer library is a powerful extension of Roblox's native buffer type that adds new data types and functionality for binary data manipulation. This library is particularly useful for data serialization, network communication, and optimized storage.</p> <ul> <li>24-bit interger (3 byte)</li> <li>40-bit interger (5 byte)</li> <li>48-bit interger (6 byte)</li> <li>54-bit interger (7 byte)</li> <li>16-bit float (2 byte)</li> </ul> <p>you will discover everything about it in this documentation.</p>"},{"location":"Utils/Buffer/#constructor-api","title":"Constructor API","text":"<p>Lets write a create a simple buffer from the library</p> Using .create()Using .from()Using .fromString()Convert the BufferComponent into a string <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myData = Buffer.create(size : number)\n</code></pre> <p>with the created BufferComponent Object you can write or read any type of value.</p> <p>.from accept a buffer and return a new BufferComponent Object please note that all data inside are not lost.</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myOldData = buffer.create(10) -- basic buffer creation\n\nlocal myNewData = Buffer.from(myOldData)\n</code></pre> <p>.fromString accept a string and return a new BufferComponent Object please note that all data inside the converted string are not lost.</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myOldData = buffer.tostring(buffer.create(10)) -- basic buffer creation\n\nlocal myNewData = Buffer.fromString(myOldData)\n</code></pre> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myOldData = Buffer.create(10)\n\nlocal stringData = Buffer.tostring(myOldData)\n</code></pre> <p>now that you know how to create a BufferComponent Object let me show how to use it.</p>"},{"location":"Utils/Buffer/#allocating-memory","title":"Allocating Memory","text":"<p>from the created BufferComponent Object you can allocate memory when needed.</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myData = Buffer.create(size : number)\n\nmyData:allocate(sizeToAllocate : number)\n</code></pre> <p>this will allocate new memory space to buffer for exemple if the buffer has a size of 10 and you allocate 5 the new buffer size will be 15 bytes</p>"},{"location":"Utils/Buffer/#writing-data","title":"Writing Data","text":"<p>for writing data inside the buffer i recommend you to look at the Constants module inside the BufferModule to look at min and max interger value</p> Writing NumberWriting String <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myData = Buffer.create(size : number)\n\nmyData:WriteI24(value : number) -- min : -8388608 max : 8388607\n</code></pre> <p>this will write a Signed Interger 24-bit (3 byte) to the buffer</p> <pre><code>local Buffer = require(somewhere.Buffer)\n\nlocal myData = Buffer.create(size : number)\n\nmyData:WriteString(\"Hello World !\") \n</code></pre> <p>other type exist for writing string such as:</p> <ul> <li>String8 - (max 8 len)</li> <li>String16 - (max 16 len)</li> <li>String32 - (max 32 len)</li> <li>String64 - (max 64 len)</li> </ul> <p>please note that these function need a len argument after passing the string to write.</p>"},{"location":"Utils/Buffer/#component-api","title":"Component API","text":""},{"location":"Utils/Buffer/#write-methods","title":"Write Methods","text":"<pre><code>-- Signed integers\nBuffer:WriteI8(number)\nBuffer:WriteI16(number)\nBuffer:WriteI24(number)\nBuffer:WriteI32(number)\nBuffer:WriteI40(number)\nBuffer:WriteI48(number)\nBuffer:WriteI54(number)\n\n-- Unsigned integers\nBuffer:WriteU1(number)\nBuffer:WriteU8(number)\nBuffer:WriteU16(number)\nBuffer:WriteU24(number)\nBuffer:WriteU32(number)\nBuffer:WriteU40(number)\nBuffer:WriteU48(number)\nBuffer:WriteU54(number)\n\n-- Float\nBuffer:WriteF16(number)\nBuffer:WriteF32(number)\nBuffer:WriteF64(number)\n\n-- String with limited length\nBuffer:WriteString8(value, length)\nBuffer:WriteString16(value, length)\nBuffer:WriteString32(value, length)\nBuffer:WriteString64(value, length)\n\n-- Full string\nBuffer:WriteString(value)\n\n-- Single boolean\nBuffer:WriteBool1(value)\n\n-- Array of 8 booleans\nBuffer:WriteBool8({true, false, true, ...})\n\n-- Roblox Types\nBuffer:WriteVector2(vector2)\nBuffer:WriteVector3(vector3)\nBuffer:WriteVector2Int16(vector2int16)\nBuffer:WriteVector3Int16(vector3int16)\nBuffer:WriteCFrame(cframe)\nBuffer:WriteLossyCFrame(cframe)\nBuffer:WriteUdim(udim)\nBuffer:WriteUdim2(udim2)\nBuffer:WriteColor3(color3)\nBuffer:WriteRect(rect)\nBuffer:WriteRegion3(region3)\nBuffer:WriteRegion3int16(region3int16)\nBuffer:WriteInstance(instance)\n</code></pre>"},{"location":"Utils/Buffer/#read-methods","title":"Read Methods","text":"<pre><code>-- Signed integers\nlocal value = Buffer:ReadI8(offset?)\nlocal value = Buffer:ReadI16(offset?)\nlocal value = Buffer:ReadI24(offset?)\nlocal value = Buffer:ReadI32(offset?)\nlocal value = Buffer:ReadI40(offset?)\nlocal value = Buffer:ReadI48(offset?)\nlocal value = Buffer:ReadI54(offset?)\n\n-- Unsigned integers\nlocal value = Buffer:ReadU8(offset?)\nlocal value = Buffer:ReadU16(offset?)\nlocal value = Buffer:ReadU24(offset?)\nlocal value = Buffer:ReadU32(offset?)\nlocal value = Buffer:ReadU40(offset?)\nlocal value = Buffer:ReadU48(offset?)\nlocal value = Buffer:ReadU54(offset?)\n\n-- Floats\nlocal value = Buffer:ReadF16(offset?)\nlocal value = Buffer:ReadF32(offset?)\nlocal value = Buffer:ReadF64(offset?)\n\n-- Strings\nlocal str = Buffer:ReadString(length?, offset?)\n\n-- Booleans\n-- Single boolean\nlocal bool = Buffer:ReadBool1(offset?)\n\n-- Array of 8 booleans\nlocal boolData = Buffer:ReadBool8(offset?)\nlocal bools = boolData.value -- Array of booleans\nlocal majority = boolData:majority() -- Returns true if more true than false\n\n-- Roblox Types\nlocal vector2 = Buffer:ReadVector2(offset?)\nlocal vector3 = Buffer:ReadVector3(offset?)\nlocal vector2int16 = Buffer:ReadVector2int16(offset?)\nlocal vector3int16 = Buffer:ReadVector3int16(offset?)\nlocal cframe = Buffer:ReadCFrame(offset?)\nlocal cframe = Buffer:ReadLossyCFrame(offset?)\nlocal udim = Buffer:ReadUdim(offset?)\nlocal udim2 = Buffer:ReadUdim2(offset?)\nlocal color3 = Buffer:ReadColor3(offset?)\nlocal rect = Buffer:ReadRect(offset?)\nlocal region3 = Buffer:ReadRegion3(offset?)\nlocal region3int16 = Buffer:ReadRegion3int16(offset?)\nlocal instance = Buffer:ReadInstance(instance_offset?)\n</code></pre>"},{"location":"Utils/Buffer/#utility-methods","title":"Utility Methods","text":"<p>allocate(size: number)</p> <p>Allocates additional memory space to the buffer.</p> <pre><code>Buffer:allocate(512) -- Adds 512 bytes\n</code></pre> <p>GetOffset()</p> <p>Returns the current write cursor position.</p> <pre><code>local offset = Buffer:GetOffset()\n</code></pre> <p>GetInstanceOffset()</p> <p>Returns the current position in the instance buffer.</p> <pre><code>local instanceOffset = Buffer:GetInstanceOffset()\n</code></pre> <p>GetBuffer()</p> <p>Returns the underlying native buffer.</p> <pre><code>local nativeBuffer = Buffer:GetBuffer()\n</code></pre> <p>GetInstanceBuffer()</p> <p>Returns the array of stored instances.</p> <pre><code>local instances = Buffer:GetInstanceBuffer()\n</code></pre> <p>GetBufferSize()</p> <p>Returns the total size of the buffer.</p> <pre><code>local size = Buffer:GetBufferSize()\n</code></pre> <p>clear()</p> <p>Resets the buffer while maintaining its size.</p> <pre><code>Buffer:clear()\n</code></pre> <p>Destroy()</p> <p>Destroys the BufferComponent and frees memory.</p> <pre><code>Buffer:Destroy()\n</code></pre>"},{"location":"Utils/Buffer/#usages","title":"Usages","text":""},{"location":"Utils/Buffer/#player-data-serialization","title":"Player Data Serialization","text":"<pre><code>local Buffer = require(path.to.Buffer)\n\n-- Create a buffer to store data\nlocal playerData = Buffer.create(256)\n\n-- Write data\nplayerData:WriteString32(\"evxry_ll\", #\"evxry_ll\") -- 8 byte len\nplayerData:WriteI32(1500) -- Score\nplayerData:WriteF32(100.5) -- Health\nplayerData:WriteVector3(Vector3.new(10, 20, 30)) -- Position\nplayerData:WriteBool1(true) -- Is alive\n\n-- Convert to string for storage\nlocal serialized = Buffer.tostring(playerData)\n</code></pre>"},{"location":"Utils/Buffer/#reading-serialized-data","title":"Reading Serialized Data","text":"<pre><code>local Buffer = require(path.to.Buffer)\n\n-- Reconstruct from string\nlocal loadedData = Buffer.fromString(serialized)\n\n-- Read data\nlocal name = loadedData:ReadString(#\"evxry_ll\", 0) -- 8 byte len\nlocal score = loadedData:ReadI32(8)\nlocal health = loadedData:ReadF32(12)\nlocal position = loadedData:ReadVector3(16)\nlocal isAlive = loadedData:ReadBool1(40)\n\nprint(name)\nprint(score)\nprint(health)\nprint(position)\nprint(isAlive)\n</code></pre>"},{"location":"Utils/Buffer/#cframe-compression","title":"CFrame Compression","text":"<pre><code>local buffer = Buffer.create(100)\n\n-- Use LossyCFrame to save space\nbuffer:WriteLossyCFrame(workspace.Part.CFrame) -- 48 bytes\n-- vs\nbuffer:WriteCFrame(workspace.Part.CFrame) -- 92 bytes\n</code></pre>"},{"location":"Utils/Buffer/#supported-data-types","title":"Supported Data Types","text":"<p>Signed Integers</p> <ul> <li>I8: -128 to 127 (1 byte)</li> <li>I16: -32,768 to 32,767 (2 bytes)</li> <li>I24: -8,388,608 to 8,388,607 (3 bytes)</li> <li>I32: -2,147,483,648 to 2,147,483,647 (4 bytes)</li> <li>I40: -549,755,813,888 to 549,755,813,887 (5 bytes)</li> <li>I48: -140,737,488,355,328 to 140,737,488,355,327 (6 bytes)</li> <li>I54: -9,007,199,254,740,992 to 9,007,199,254,740,991 (7 bytes)</li> </ul> <p>Unsigned Integers</p> <ul> <li>U1: 0 to 1 (1 byte)</li> <li>U8: 0 to 255 (1 byte)</li> <li>U16: 0 to 65,535 (2 bytes)</li> <li>U24: 0 to 16,777,215 (3 bytes)</li> <li>U32: 0 to 4,294,967,295 (4 bytes)</li> <li>U40: 0 to 1,099,511,627,775 (5 bytes)</li> <li>U48: 0 to 281,474,976,710,655 (6 bytes)</li> <li>U54: 0 to 18,014,398,509,481,984 (7 bytes)</li> </ul> <p>Roblox Types</p> <ul> <li>Vector2 (16 bytes)</li> <li>Vector3 (24 bytes)</li> <li>Vector2int16 (4 bytes)</li> <li>Vector3int16 (6 bytes)</li> <li>CFrame (92 bytes)</li> <li>LossyCFrame (48 bytes) - Compressed version with precision loss</li> <li>UDim (8 bytes)</li> <li>UDim2 (16 bytes)</li> <li>Color3 (12 bytes)</li> <li>Rect (32 bytes)</li> <li>Region3 (116 bytes)</li> <li>Region3int16 (12 bytes)</li> </ul> <p>Other Types</p> <ul> <li>String (variable length)</li> <li>String8/16/32/64 (limited length)</li> <li>Bool1 (1 byte)</li> <li>Bool8 (1 byte for 8 booleans)</li> <li>Instance (stored separately)</li> </ul>"},{"location":"Utils/Buffer/#important-notes","title":"Important Notes","text":"<ul> <li> <p>Memory Management: Numeric values are automatically clamped to the min/max values of the type.</p> </li> <li> <p>Offset: The offset is automatically incremented after each write. For reading, you can specify a custom offset.</p> </li> <li> <p>Instances: Instances are stored in a separate buffer and are not serialized in the main buffer.</p> </li> <li> <p>Performance: Custom types (I24, I40, I48, I54, etc.) are less performant than native types as they require multiple bitwise operations.</p> </li> <li> <p>Precision: F16 and LossyCFrame sacrifice precision to save space.</p> </li> </ul>"},{"location":"Utils/Buffer/#license","title":"License","text":"<p>See the LICENSE file for information about using and redistributing this library.</p>"},{"location":"Utils/Enum/","title":"Enum","text":""},{"location":"Utils/Enum/#overview","title":"Overview","text":"<p>This module provides a system for creating and managing enums in Lua/Luau. Enums are useful for creating named constants that represent specific values, making code more readable and maintainable.</p> <p>Features:</p> <ul> <li>Create enums with string keys and numeric values</li> <li>Automatic value assignment based on order</li> <li>Enum caching to prevent duplicate creation</li> <li>Type-safe enum access</li> <li>Frozen enums to prevent modification</li> </ul>"},{"location":"Utils/Enum/#installation","title":"Installation","text":""},{"location":"Utils/Enum/#module-enum","title":"Module : Enum","text":""},{"location":"Utils/Enum/#quick-example","title":"Quick example","text":"<pre><code>--[[\n    This script demonstrates the usage of the Enum module.\n    It imports required modules and creates a sample enum.\n]]\n\n-- Get reference to ReplicatedStorage service where modules are stored\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n-- Import the main Enum module that provides enum creation functionality\nlocal EnumModule = require(ReplicatedStorage.Enum.Enum)\n\n-- Import the EnumType module that contains type definitions for enums\nlocal EnumType = require(ReplicatedStorage.Enum.EnumType)\n\n--[[\n    Creates a new enum called \"Hello-World\" with three values: A, B, and C\n\n    The type casting :: {EnumType.HelloKeys} ensures type safety by specifying\n    that the items array should match the HelloKeys type definition.\n\n    The final type cast :: EnumType.HelloEnum&lt;\"Hello\"&gt; ensures the returned\n    enum matches the expected HelloEnum type structure.\n\n    This creates an enum where:\n    - HelloEnum.A = {Value = 1, Name = \"A\", EnumType = \"Hello-World\"}\n    - HelloEnum.B = {Value = 2, Name = \"B\", EnumType = \"Hello-World\"}\n    - HelloEnum.C = {Value = 3, Name = \"C\", EnumType = \"Hello-World\"}\n]]\nlocal HelloEnum = EnumModule.new(\"Hello-World\",{\"A\",\"B\",\"C\"} :: {EnumType.HelloKeys}) :: EnumType.HelloEnum&lt;\"Hello\"&gt;\n</code></pre>"},{"location":"Utils/Enum/#api","title":"API","text":""},{"location":"Utils/Enum/#constructors","title":"Constructors","text":"<ul> <li><code>new&lt;Name, Keys&gt;(EnumName : Name,Items : {Keys}) -&gt; : {[string] : EnumIndex&lt;Name&gt;}</code></li> </ul> <p>Creates a new enum with the given name and items.</p> <p>If an enum with the same name already exists, returns the existing enum. Otherwise, creates a new enum with auto-assigned numeric values.</p> <ul> <li> <p>@param EnumName The unique name for this enum</p> </li> <li> <p>@param items Array of string keys for the enum values</p> </li> <li> <p>@return A frozen table mapping keys to EnumIndex objects</p> </li> </ul> <pre><code>local Colors = EnumConstructor.new(\"Colors\", {\"Red\", \"Green\", \"Blue\"})\n-- Colors.Red = {Value = 1, Name = \"Red\", EnumType = \"Colors\"}\n</code></pre> <ul> <li><code>from&lt;Name&gt;(EnumName : Name) -&gt; : {[string] : EnumIndex&lt;Name&gt;}</code></li> </ul> <p>Creates a new enum with the given name and items.</p> <p>If an enum with the same name already exists, returns the existing enum. Otherwise, creates a new enum with auto-assigned numeric values.</p> <ul> <li> <p>@param EnumName The unique name for this enum</p> </li> <li> <p>@param items Array of string keys for the enum values</p> </li> <li> <p>@return A frozen table mapping keys to EnumIndex objects</p> </li> </ul> <pre><code>local Colors = EnumConstructor.new(\"Colors\", {\"Red\", \"Green\", \"Blue\"})\n-- Colors.Red = {Value = 1, Name = \"Red\", EnumType = \"Colors\"}\n</code></pre> <ul> <li><code>RemoveEnum&lt;Name&gt;(EnumName : Name) -&gt; ()</code></li> </ul> <p>Removes an enum from the registry.</p> <p>This clears the enum table and removes it from the registry, allowing a new enum with the same name to be created.</p> <ul> <li>@param EnumName The name of the enum to remove</li> </ul> <pre><code>EnumConstructor.RemoveEnum(\"Colors\")\n</code></pre>"},{"location":"Utils/Enum/#types","title":"Types","text":"<p>To add a new enum type open the EnumType module inside the Enum folder:</p> <ol> <li>Define a Keys type with all possible enum values</li> <li>Define an Enum type with the structure mapping keys to EnumIndex</li> </ol>"},{"location":"Utils/Enum/#default-inserted-enum","title":"Default inserted enum","text":"<p>Example enum type definitions These demonstrate how to create type-safe enum definitions</p> <p>HelloKeys defines the allowed string values for the Hello enum Using a union type ensures only these specific strings can be used</p> <pre><code>export type HelloKeys = \"A\" | \"B\" | \"C\"\n</code></pre> <p>HelloEnum defines the structure of the Hello enum It maps each key to an EnumIndex with the appropriate enum name The generic parameter EnumName allows flexibility in the enum type name</p> <pre><code>export type HelloEnum&lt;EnumName = string&gt; = {\n    A: EnumIndex&lt;EnumName&gt;,  -- Enum item A\n    B: EnumIndex&lt;EnumName&gt;,  -- Enum item B\n    C: EnumIndex&lt;EnumName&gt;,  -- Enum item C\n}\n</code></pre> <p>now you can see Quick example for testing the enum with your own type.</p>"},{"location":"Utils/ModuleLoader/","title":"ModuleLoader","text":""},{"location":"Utils/ModuleLoader/#overview","title":"Overview","text":"<p>ModuleLoader is a lightweight utility to load, initialize, start, and clean up your Roblox ModuleScripts in a folder and its subfolders. It supports:</p> <ul> <li>Per-module priorities (via the \"Priority\" attribute)</li> <li>Sorting modules by descending priority</li> <li>A consistent lifecycle: Init \u2192 Start \u2192 Cleaning</li> <li>Multiple load calls (you can call Load on multiple roots)</li> <li>Server and client execution with distinct logs</li> </ul> <p>Each ModuleScript must return a table with at least <code>Init</code> and <code>Start</code>, and optionally <code>Cleaning</code>.</p>"},{"location":"Utils/ModuleLoader/#module-moduleloader","title":"Module : ModuleLoader","text":""},{"location":"Utils/ModuleLoader/#key-features","title":"Key features","text":"<ul> <li>Recursive loading (depending on USE_DESCENDANT)</li> <li>Ordered start (higher priority first)</li> <li>API to filter/control startup (Each)</li> <li>Global cleanup (Clear/Stop)</li> <li>Find a loaded module (Find)</li> </ul>"},{"location":"Utils/ModuleLoader/#quick-example","title":"Quick example","text":"<p>Assume ModuleLoader.luau is in ReplicatedStorage.</p> <pre><code>-- ServerScriptService/ServerMain.server.lua\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ServerScriptService = game:GetService(\"ServerScriptService\")\n\nlocal ModuleLoader = require(ReplicatedStorage.ModuleLoader)\n\nModuleLoader.SetSettings({\n    SHOW_DEBUG_PRINT = true,  -- Show logs\n    USE_DESCENDANT    = true, -- Traverse all descendants\n})\n\n-- Load all modules under ServerScriptService/Modules\nModuleLoader.Load(ServerScriptService:WaitForChild(\"Modules\"))\n\n-- Start modules in priority order\nModuleLoader.Start()\n</code></pre>"},{"location":"Utils/ModuleLoader/#installation","title":"Installation","text":"<ul> <li>Create a ModuleScript named <code>ModuleLoader</code> (or import the existing file) in <code>ReplicatedStorage</code> (recommended), or any shared location.</li> <li>Put your target ModuleScripts in a folder (e.g., <code>ServerScriptService/Modules</code>).</li> </ul>"},{"location":"Utils/ModuleLoader/#minimal-module-structure","title":"Minimal module structure","text":"<pre><code>local MyModule = {}\n\nfunction MyModule:Init()\n    -- Setup (must not yield)\nend\n\nfunction MyModule:Start()\n    -- Start (must not yield)\nend\n\nfunction MyModule:Cleaning()\n    -- Optional: cleanup\nend\n\nreturn MyModule\n</code></pre> <p>Important: Init and Start must not yield (avoid waits that block execution).</p>"},{"location":"Utils/ModuleLoader/#server","title":"Server","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ServerScriptService = game:GetService(\"ServerScriptService\")\nlocal ModuleLoader = require(ReplicatedStorage.ModuleLoader)\n\nModuleLoader.SetSettings({\n    SHOW_DEBUG_PRINT = true,\n    USE_DESCENDANT = true,\n})\n\nModuleLoader.Load(ServerScriptService.Modules)\nModuleLoader.Start()\n</code></pre>"},{"location":"Utils/ModuleLoader/#client","title":"Client","text":"<pre><code>-- StarterPlayerScripts/ClientMain.client.lua\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal StarterPlayerScripts = game:GetService(\"StarterPlayerScripts\")\n\nlocal ModuleLoader = require(ReplicatedStorage.ModuleLoader)\n\nModuleLoader.SetSettings({\n    SHOW_DEBUG_PRINT = true,\n    USE_DESCENDANT = true,\n})\n\nModuleLoader.Load(StarterPlayerScripts:WaitForChild(\"ClientModules\"))\nModuleLoader.Start()\n</code></pre>"},{"location":"Utils/ModuleLoader/#attributes-and-priorities","title":"Attributes and priorities","text":"<p>Set a module\u2019s priority via ModuleScript:SetAttribute(\"Priority\", number). Higher priority runs earlier. If priorities are equal, load order is used. text</p>"},{"location":"Utils/ModuleLoader/#settings-setsettings","title":"Settings (SetSettings)","text":"<pre><code>ModuleLoader.SetSettings({\n  SHOW_DEBUG_PRINT = boolean, -- true = show logs\n  USE_DESCENDANT   = boolean, -- true = GetDescendants(), false = only GetChildren()\n})\n</code></pre> <p>Call SetSettings before Start. You can call Load multiple times to gather modules from different roots.</p>"},{"location":"Utils/ModuleLoader/#loading","title":"Loading","text":"<pre><code>ModuleLoader.Load(someFolderOrInstance)\n</code></pre> <p>If USE_DESCENDANT = true: collects all ModuleScripts under the instance.</p> <p>Otherwise: only immediate children (you can Load subfolders yourself to recurse).</p>"},{"location":"Utils/ModuleLoader/#global-start","title":"Global start","text":"<pre><code>ModuleLoader.Start()\n</code></pre> <p>Calls :Init() then :Start() on each module, sorted by descending priority.</p> <p>Do not call twice (assertion).</p>"},{"location":"Utils/ModuleLoader/#selective-start-each","title":"Selective start (Each)","text":"<pre><code>ModuleLoader.Each(function(moduleScript)\n  -- Return true to start this module, false to skip it\n  return moduleScript:GetAttribute(\"Run\") ~= false\nend)\n</code></pre> <p>Each lets you filter which modules to run (e.g., by attribute, tag, or name). Do not call after Start (assertion).</p>"},{"location":"Utils/ModuleLoader/#cleanup-and-restart","title":"Cleanup and restart","text":"<p>ModuleLoader.Clear() calls :Cleaning() on each module (if present) then wipes the registry. ModuleLoader.Stop() calls Clear() and resets the started state so you can load/start again.</p>"},{"location":"Utils/ModuleLoader/#tips","title":"Tips","text":"<p>Put ModuleLoader in ReplicatedStorage to share it between server and client.</p> <p>Modules are required at Load time, so top-level code in your modules runs during loading.</p> <p>Init/Start must not yield (no unbounded WaitForChild or network waits).</p>"},{"location":"Utils/ModuleLoader/#api","title":"API","text":""},{"location":"Utils/ModuleLoader/#types","title":"Types","text":"<ul> <li>Settings</li> <li>SHOW_DEBUG_PRINT: boolean</li> <li> <p>USE_DESCENDANT: boolean</p> </li> <li> <p>RegisteryIndex</p> </li> <li>instance: ModuleScript</li> <li>module: ModuleLoaderComponent</li> <li> <p>priority: number</p> </li> <li> <p>ModuleLoaderComponent</p> </li> <li>Init: (...any) -&gt; ()</li> <li>Start: (...any) -&gt; ()</li> <li>Cleaning: (...any) -&gt; () | nil</li> </ul>"},{"location":"Utils/ModuleLoader/#functions","title":"Functions","text":""},{"location":"Utils/ModuleLoader/#moduleloadersetsettingscustomsettings-settings-","title":"ModuleLoader.SetSettings(customSettings: Settings) -&gt; ()","text":"<ul> <li>Sets the loader\u2019s global settings.</li> <li>Call before <code>Start</code>.</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloaderloaddescendant-instance-","title":"ModuleLoader.Load(descendant: Instance) -&gt; ()","text":"<ul> <li>Finds and require()s all ModuleScripts under <code>descendant</code>.</li> <li>May be called multiple times with different roots.</li> <li>Sorts the registry by descending priority after loading.</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloaderstart-","title":"ModuleLoader.Start() -&gt; ()","text":"<ul> <li>Starts all loaded modules:   1) Calls <code>:Init()</code>   2) Calls <code>:Start()</code></li> <li>Asserts if already started.</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloadereachcallback-module-modulescript-boolean-","title":"ModuleLoader.Each(callback: (module: ModuleScript) -&gt; boolean) -&gt; ()","text":"<ul> <li>Iterates over all loaded modules.</li> <li>For each module, if <code>callback(moduleScript)</code> returns true, calls <code>:Init()</code> and then <code>:Start()</code> for that module.</li> <li>Asserts if already started.</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloaderclear-","title":"ModuleLoader.Clear() -&gt; ()","text":"<ul> <li>If a module exposes <code>Cleaning</code>, calls it.</li> <li>Clears the registry.</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloaderstop-","title":"ModuleLoader.Stop() -&gt; ()","text":"<ul> <li>Calls <code>Clear()</code> and resets <code>started = false</code>. You can then <code>Load</code>/<code>Start</code> again.</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloaderfindmodulepath-modulescript-string-registeryindex","title":"ModuleLoader.Find(ModulePath: ModuleScript | string) -&gt; RegisteryIndex?","text":"<ul> <li>Locates a previously loaded module:</li> <li>By name (string)</li> <li>By instance (ModuleScript)</li> <li>Returns the <code>RegisteryIndex</code> entry (or nil if not found).</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloaderwaituntilstarted-number","title":"ModuleLoader.WaitUntilStarted() -&gt; number","text":"<ul> <li>return the elapsted time until the module loader start.</li> </ul>"},{"location":"Utils/ModuleLoader/#moduleloaderisstarted-boolean","title":"ModuleLoader.IsStarted() -&gt; boolean","text":"<ul> <li>return trued if the module loader is started.</li> </ul>"},{"location":"Utils/ModuleLoader/#serverclient-logs","title":"Server/client logs","text":"<ul> <li> <p>Server messages are prefixed with <code>[S] --&gt;</code></p> </li> <li> <p>Client messages are prefixed with <code>[C] --&gt;</code></p> </li> </ul>"},{"location":"Utils/ModuleLoader/#exemples","title":"Exemples","text":""},{"location":"Utils/ModuleLoader/#1-priorities-and-multiple-roots","title":"1) Priorities and multiple roots","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ServerScriptService = game:GetService(\"ServerScriptService\")\n\nlocal ModuleLoader = require(ReplicatedStorage.ModuleLoader)\n\nModuleLoader.SetSettings({\n  SHOW_DEBUG_PRINT = true,\n  USE_DESCENDANT = true,\n})\n\n-- Load from multiple roots\nModuleLoader.Load(ServerScriptService.Modules)\nModuleLoader.Load(ServerScriptService.Features)\n\n-- Set priorities in Studio using attributes\n-- e.g., ClickerModule.Priority = 100, UIModule.Priority = 50\n\nModuleLoader.Start()\n</code></pre>"},{"location":"Utils/Nexus/","title":"Nexus","text":""},{"location":"Utils/Nexus/#overview","title":"Overview","text":"<p>This library provides a structured way to manage RemoteEvents and RemoteFunctions between client and server in Roblox. It introduces two main components:</p> <p>Nexus include two components</p> <ul> <li>Client Component \u2014 Handles client-side communication with server remotes.</li> <li>Server Component \u2014 Handles server-side communication with client remotes.</li> </ul> <p>Both components include validation support, event binding, safe connection handling, and clean-up mechanisms.</p>"},{"location":"Utils/Nexus/#module-nexus","title":"Module: Nexus","text":""},{"location":"Utils/Nexus/#nexusclient-component","title":"Nexus.Client Component","text":""},{"location":"Utils/Nexus/#creating-a-client-component","title":"Creating a Client Component","text":"<pre><code>local Nexus = require(path.to.Nexus)\n\nlocal client = Nexus.Client.new({\n    Name = \"MyRemoteEvent\",\n    RemoteType = \"RemoteEvent\",\n    Validator = function(...)\n        -- Optional: Validate incoming data\n        return true\n    end\n})\n</code></pre>"},{"location":"Utils/Nexus/#methods","title":"Methods","text":"<p><code>Client.new(RemoteConfig: RemoteConfiguration) : ClientComponent</code></p> <p>Creates and initializes a new client component, connecting to the specified remote.</p> <p><code>ClientComponent:OnClientEvent(callback: (...any) -&gt; ()) : RBXScriptConnection</code> Registers a function to handle events received from the server.</p> <p>Example: <pre><code>client:OnClientEvent(function(message)\n    print(\"Received from server:\", message)\nend)\n</code></pre></p> <p><code>ClientComponent:FireServer(...: any)</code></p> <p>Sends data to the server through <code>FireServer</code>.</p> <p>Example: <pre><code>client:FireServer(\"Hello from client!\")\n</code></pre></p> <p><code>ClientComponent:InvokeServer(...: any) : any</code></p> <p>Calls a server-side RemoteFunction and returns the response.</p> <p>Example: <pre><code>local result = client:InvokeServer(\"RequestData\")\nprint(\"Server replied:\", result)\n</code></pre></p> <p><code>ClientComponent:Handle(callback: (Player: Player, ...any) -&gt; ())</code></p> <p>Assigns a callback for <code>OnClientInvoke</code> (rarely used for client components; typically server-side).</p> <p><code>ClientComponent:Disconnect()</code></p> <p>Disconnects the registered <code>OnClientEvent</code> listener.</p> <p><code>ClientComponent:Destroy()</code></p> <p>Cleans up the component and removes event listeners.</p>"},{"location":"Utils/Nexus/#server-component","title":"Server Component","text":""},{"location":"Utils/Nexus/#creating-a-server-component","title":"Creating a Server Component","text":"<pre><code>local Nexus = require(path.to.Nexus)\n\nlocal server = Nexus.Server.new({\n    Name = \"MyRemoteEvent\",\n    RemoteType = \"RemoteEvent\",\n    Validator = function(player, ...)\n        -- Example: allow only specific players\n        return player.UserId == 123456\n    end\n})\n</code></pre>"},{"location":"Utils/Nexus/#methods_1","title":"Methods","text":"<p><code>Server.new(RemoteConfig: RemoteConfiguration) : ServerComponent</code></p> <p>Creates and initializes a new server component, creating the remote if it does not exist.</p> <p><code>ServerComponent:OnServerEvent(callback: (Player: Player, ...any) -&gt; ()) : RBXScriptConnection</code></p> <p>Registers a function to handle events received from clients.</p> <p>Example: <pre><code>server:OnServerEvent(function(player, message)\n    print(player.Name .. \" says:\", message)\nend)\n</code></pre></p> <p><code>ServerComponent:FireClient(player: Player, ...: any)</code></p> <p>Sends data to a specific client.</p> <p>Example: <pre><code>server:FireClient(game.Players.JohnDoe, \"Hello from server!\")\n</code></pre></p> <p><code>ServerComponent:InvokeClient(player: Player, ...: any) : any</code></p> <p>Calls a client-side RemoteFunction and waits for a return value.</p> <p>Example: <pre><code>local response = server:InvokeClient(game.Players.JohnDoe, \"Ping\")\nprint(\"Client replied:\", response)\n</code></pre></p> <p><code>ServerComponent:Handle(callback: (Player: Player, ...any) -&gt; ())</code></p> <p>Assigns a callback for <code>OnServerInvoke</code> to handle client RemoteFunction calls.</p> <p>Example: <pre><code>server:Handle(function(player, data)\n    return \"Data received: \" .. tostring(data)\nend)\n</code></pre></p> <p><code>ServerComponent:Disconnect()</code></p> <p>Disconnects the registered <code>OnServerEvent</code> listener.</p> <p><code>ServerComponent:Destroy()</code></p> <p>Cleans up the component, disconnects events, and destroys the remote instance.</p>"},{"location":"Utils/Nexus/#best-practices","title":"Best Practices","text":"<ul> <li>Always use <code>Validator</code> functions to filter and validate incoming data.</li> <li>Always <code>Disconnect()</code> or <code>Destroy()</code> components when no longer needed.</li> <li>Keep <code>RemoteConfiguration.Name</code> unique per remote to avoid conflicts.</li> <li>Use <code>InvokeServer</code>/<code>InvokeClient</code> only for request-response logic; prefer <code>FireServer</code>/<code>FireClient</code> for standard events.</li> </ul>"},{"location":"Utils/Nexus/#example-full-usage","title":"Example Full Usage","text":"<p>Server-side <pre><code>local Server = require(path.to.Nexus).Server\n\nlocal chatServer = Server.new({\n    Name = \"ChatMessage\",\n    RemoteType = \"RemoteEvent\",\n    Validator = function(player, message)\n        return typeof(message) == \"string\" and #message &gt; 0\n    end\n})\n\nchatServer:OnServerEvent(function(player, message)\n    print(player.Name .. \": \" .. message)\n    -- Send message to all players\n    for _, p in ipairs(game.Players:GetPlayers()) do\n        chatServer:FireClient(p, player.Name .. \": \" .. message)\n    end\nend)\n</code></pre></p> <p>Client-side <pre><code>local Client = require(path.to.Nexus).Client\n\nlocal chatClient = Client.new({\n    Name = \"ChatMessage\",\n    RemoteType = \"RemoteEvent\"\n})\n\nchatClient:OnClientEvent(function(message)\n    print(\"[Chat] \" .. message)\nend)\n\n-- Send message to server\nchatClient:FireServer(\"Hello everyone!\")\n</code></pre></p>"},{"location":"Utils/Option/","title":"Option","text":""},{"location":"Utils/Option/#overview","title":"Overview","text":"<p>This module implements a Rust-like <code>Option&lt;T&gt;</code>:</p> <ul> <li><code>Some(value)</code> holds a value of type <code>T</code></li> <li><code>None</code> represents the absence of a value</li> </ul> <p>It helps you avoid nil checks sprinkled across your code and centralizes handling via:</p> <ul> <li>Safe accessors (<code>GetOr</code>, <code>GetOrElse</code>, <code>UnwrapOr</code>, <code>Expect</code>, \u2026)</li> <li>Transformations (<code>Map</code>, <code>AndThen</code>)</li> <li>Predicates (<code>IsSome</code>, <code>IsNone</code>, <code>Contains</code>, <code>Filter</code>)</li> <li>Combinators (<code>XOR</code>)</li> <li>Pattern matching (<code>Match</code>)</li> <li>Serialization (<code>Serialize</code>, <code>Deserialize</code>)</li> </ul> <p>Lowercase aliases are provided (e.g., <code>unwrap</code>, <code>getOr</code>, <code>andThen</code>, \u2026) in addition to PascalCase.</p>"},{"location":"Utils/Option/#getting-started","title":"Getting started","text":""},{"location":"Utils/Option/#installation","title":"Installation","text":""},{"location":"Utils/Option/#download-option","title":"Download : Option","text":"<ul> <li>Place the Option module (this file) in a shared location like <code>ReplicatedStorage</code>.</li> <li>Require it where you need it:</li> </ul> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Option = require(ReplicatedStorage.Option)\n</code></pre>"},{"location":"Utils/Option/#quick-example","title":"Quick example","text":"<pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Option = require(ReplicatedStorage.Option)\n\n-- Wrap a possibly-nil value (Some if not nil, otherwise None)\nlocal maybePart = Option.Wrap(workspace:FindFirstChild(\"SpawnLocation\"))\n\n-- Access with default:\nlocal part = maybePart:GetOr(workspace.Terrain)\n\n-- Filter + transform + default:\nlocal displayName =\n    Option.Wrap(game.Players.LocalPlayer and game.Players.LocalPlayer.DisplayName)\n        :Filter(function(n) return #n &gt; 0 end)\n        :Map(function(n) return n:upper() end) -- Map keeps the same type\n        :GetOr(\"GUEST\")\n\nprint(\"Display:\", displayName)\n\n-- Pattern match:\nmaybePart:Match({\n  Some = function(p) print(\"Found part:\", p.Name); return nil end,\n  None = function() print(\"No part found\"); return nil end,\n})\n\n-- Unwrap with message (throws if None)\nlocal requiredPart = maybePart:Expect(\"SpawnLocation is required!\")\n</code></pre>"},{"location":"Utils/Option/#api","title":"API","text":""},{"location":"Utils/Option/#types","title":"Types","text":"<ul> <li>Some&lt;T&gt; = T <li>None = () -&gt; ()</li> <li>Callback&lt;T&gt; = () -&gt; T <li>MappedCallback&lt;T&gt; = (value: T) -&gt; T <li>FilterCallback&lt;T&gt; = (value: T) -&gt; boolean <li> <p>AndThenCallback&lt;T, K&gt; = (value: T) -&gt; any <li> <p>OptionComponent&lt;T&gt; (metatable-backed) <li>Fields:<ul> <li>Tag: \"Some\" | \"None\"</li> <li>Some: T</li> <li>None: nil</li> </ul> </li> <li>Methods: see below</li>"},{"location":"Utils/Option/#constructors","title":"Constructors","text":"<ul> <li>Option.Some&lt;T&gt;(value: T) : OptionComponent&lt;T&gt; <li>Option.None() : OptionComponent <li>Option.IsOption&lt;T&gt;(value: any) : boolean <li>Option.Wrap&lt;T&gt;(value: T?) : OptionComponent&lt;T&gt; | OptionComponent&lt;nil&gt; <li>Option.Deserialize&lt;T&gt;(data: { Tag: \"Some\" | \"None\", Value: T }) : OptionComponent&lt;T&gt;"},{"location":"Utils/Option/#option-methods","title":"Option methods","text":"<ul> <li>IsSome&lt;T&gt;(self): boolean <li>IsNone&lt;T&gt;(self): boolean <li>Match&lt;T&gt;(self, opts: { Some: (T) -&gt; any, None: () -&gt; any }) : any <li>Assert&lt;T&gt;(self, errorMessage: string) : () <li>GetOr&lt;T, K&gt;(self, defaultValue: K) : T | K <li>Map&lt;T&gt;(self, fn: (T) -&gt; T) : OptionComponent&lt;T&gt; <li>Filter&lt;T&gt;(self, pred: (T) -&gt; boolean) : OptionComponent&lt;T&gt; | OptionComponent&lt;T&gt; <li>GetOrElse&lt;T, K&gt;(self, fn: () -&gt; K) : T | K <li>XOR&lt;T&gt;(self, other: OptionComponent&lt;T&gt;) : OptionComponent&lt;T&gt; | OptionComponent&lt;T&gt; <li>AndThen&lt;T, K&gt;(self, fn: (T) -&gt; OptionComponent&lt;K&gt;) : OptionComponent&lt;T&gt; | OptionComponent&lt;K&gt; <li>Expect&lt;T&gt;(self, msg: string): T <li>ExpectNone&lt;T&gt;(self, msg: string) : () <li>UnWrap&lt;T&gt;(self) : T <li>UnWrapOr&lt;T, K&gt;(self, defaultValue: K) : T | K <li>UnWrapOrElse&lt;T, K&gt;(self, fn: () -&gt; K) : T | K <li>Contains&lt;T, K&gt;(self, value: K) : boolean <li>Serialize&lt;T&gt;(self) : { Tag: \"Some\" | \"None\", Value?: T }"},{"location":"Utils/Option/#metamethods","title":"Metamethods","text":"<ul> <li>__tostring(self): string</li> <li>__eq(self, other): boolean</li> </ul>"},{"location":"Utils/Option/#aliases","title":"Aliases","text":"<pre><code>-- Lowercase aliases for methods (alternative naming convention)\n-- These provide the same functionality with camelCase naming\nOptionComponent.Unwrap = OptionComponent.UnWrap\nOptionComponent.UnwrapOr = OptionComponent.UnWrapOr\nOptionComponent.getOr = OptionComponent.GetOr\nOptionComponent.getOrElse = OptionComponent.GetOrElse\nOptionComponent.expectNone = OptionComponent.ExpectNone\nOptionComponent.andThen = OptionComponent.AndThen\nOptionComponent.map = OptionComponent.Map\nOptionComponent.filter = OptionComponent.Filter\nOptionComponent.assert = OptionComponent.Assert\nOptionComponent.match = OptionComponent.Match\nOptionComponent.contains = OptionComponent.Contains\nOptionComponent.isNone = OptionComponent.IsNone\nOptionComponent.isSome = OptionComponent.IsSome\nOptionComponent.serialize = OptionComponent.Serialize\n\n-- OptionConstructor lowercase aliases\nOptionConstructor.isOption = OptionConstructor.IsOption\nOptionConstructor.deserialize = OptionConstructor.Deserialize\n</code></pre>"},{"location":"Utils/Option/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Utils/Option/#called-unwrap-on-none","title":"\"Called UnWrap() on None\"","text":"<ul> <li>You called <code>UnWrap()</code>/<code>Unwrap()</code> on a <code>None</code>. Use <code>GetOr</code>, <code>GetOrElse</code>, or <code>Expect</code> with a message.</li> </ul>"},{"location":"Utils/Option/#my-map-lost-the-type-i-wanted","title":"My <code>Map</code> lost the type I wanted","text":"<ul> <li><code>Map</code> is monomorphic: <code>(T) -&gt; T</code>. To change type (e.g., string \u2192 number), use <code>AndThen</code> and return another <code>Option</code>.</li> </ul>"},{"location":"Utils/Option/#current-callback-must-return-a-optioncomponent","title":"\"current callback must return a OptionComponent.\"","text":"<ul> <li>Your <code>AndThen</code> callback must return an <code>Option</code> (i.e., <code>Option.Some(...)</code> or <code>Option.None()</code>).</li> </ul>"},{"location":"Utils/Option/#match-signature-confusion","title":"<code>Match</code> signature confusion","text":"<ul> <li><code>Match</code> executes either <code>opts.None()</code> or <code>opts.Some(value)</code>. It returns whatever your callback returns. Keep callbacks side-effect-safe.</li> </ul>"},{"location":"Utils/Option/#optionisoption-returned-false","title":"<code>Option.IsOption</code> returned false","text":"<ul> <li><code>IsOption</code> checks for a <code>Tag</code> field. Ensure you're passing an <code>Option</code> created by this module.</li> </ul>"},{"location":"Utils/Option/#equality-not-behaving-as-expected","title":"Equality not behaving as expected","text":"<ul> <li><code>Some(a) == Some(b)</code> uses <code>a == b</code>. If <code>a</code> and <code>b</code> are tables, that\u2019s reference equality by default in Luau.</li> </ul>"},{"location":"Utils/Option/#serialization-pitfalls","title":"Serialization pitfalls","text":"<ul> <li><code>Serialize</code> stores raw <code>Value</code>. Ensure the value is serializable (no cyclic references, userdata, etc.).</li> </ul>"},{"location":"Utils/Option/#design-notes","title":"Design notes","text":"<ul> <li>The Option is represented as a table with a <code>Tag</code>:</li> <li><code>Tag = \"Some\"</code> and a <code>Some</code> field containing the value</li> <li><code>Tag = \"None\"</code> (and an internal <code>None = true</code> field)</li> <li><code>IsOption</code> uses a structural check (<code>option and option.Tag</code>)\u2014simple and fast.</li> </ul>"},{"location":"Utils/Option/#map-vs-andthen","title":"Map vs. AndThen","text":"<ul> <li><code>Map</code> keeps the type: <code>(T) -&gt; T</code>.</li> <li><code>AndThen</code> allows changing type: <code>(T) -&gt; Option&lt;K&gt;</code>; it asserts that the callback returns an <code>Option</code>.</li> </ul>"},{"location":"Utils/Option/#pattern-matching","title":"Pattern matching","text":"<ul> <li><code>Match</code> expects a table with <code>Some</code> and <code>None</code> callbacks:   ```lua   opt:Match({     Some = function(v) ... end,     None = function() ... end,   })</li> </ul>"},{"location":"Utils/SyncHandler/","title":"SyncHandler","text":""},{"location":"Utils/SyncHandler/#overview","title":"Overview","text":"<p>A sophisticated handler system built on top of Roblox's BindableFunction that provides synchronous function invocation with timeout protection. This module ensures that only one handler can be registered at a time, making it ideal for request-response patterns where multiple handlers could cause conflicts or ambiguous behavior.</p>"},{"location":"Utils/SyncHandler/#key-features","title":"Key Features","text":"<ul> <li>Single handler enforcement (only one callback can handle invocations at a time)</li> <li>Configurable timeout system to prevent indefinite waiting</li> <li>Global registry to prevent duplicate handlers with the same name</li> <li>Type-safe generic implementation supporting any argument types</li> <li>Clean disconnection mechanism that returns a cleanup function</li> </ul>"},{"location":"Utils/SyncHandler/#use-cases","title":"Use cases","text":"<ul> <li>Inter-script communication requiring responses</li> <li>Synchronous API implementations</li> <li>Request-response patterns between different parts of your game</li> </ul>"},{"location":"Utils/SyncHandler/#installation-synchandler","title":"Installation: SyncHandler","text":""},{"location":"Utils/SyncHandler/#quick-example","title":"Quick example","text":"<pre><code>-- Script 1: Setting up the handler\nlocal SyncHandler = require(path.to.SyncHandler)\n\n-- Create a handler for calculator operations\nlocal calculatorHandler = SyncHandler.new(\"Calculator\")\n\n-- Register a handler that performs calculations\nlocal disconnect = calculatorHandler:OnInvoke(function(operation, a, b)\n    print(\"Handler received:\", operation, a, b)\n\n    if operation == \"add\" then\n        return a + b\n    elseif operation == \"multiply\" then\n        return a * b\n    elseif operation == \"divide\" then\n        if b == 0 then\n            return nil, \"Cannot divide by zero\"\n        end\n        return a / b\n    else\n        return nil, \"Unknown operation\"\n    end\nend)\n\n-- The handler is now ready to receive invocations\n-- Invoke some calculations\nlocal result1 = calculatorHandler:Invoke(\"add\", 5, 3)\nprint(\"5 + 3 =\", result1) -- Output: 5 + 3 = 8\n\nlocal result2 = calculatorHandler:Invoke(\"multiply\", 4, 7)\nprint(\"4 * 7 =\", result2) -- Output: 4 * 7 = 28\n\nlocal result3, error = calculatorHandler:Invoke(\"divide\", 10, 2)\nprint(\"10 / 2 =\", result3) -- Output: 10 / 2 = 5\n\n-- Try dividing by zero\nlocal result4, error = calculatorHandler:Invoke(\"divide\", 10, 0)\nif error then\n    print(\"Error:\", error) -- Output: Error: Cannot divide by zero\nend\n</code></pre>"},{"location":"Utils/SyncHandler/#api","title":"API","text":""},{"location":"Utils/SyncHandler/#constructor","title":"Constructor","text":""},{"location":"Utils/SyncHandler/#newtname-string-synchandlercomponentt","title":"<code>new&lt;T...&gt;(Name : string) -&gt; SyncHandlerComponent&lt;T...&gt;</code>","text":"<p>Creates a new SyncHandler instance or returns an existing one with the same name</p> <ul> <li>@param Name - A unique string identifier for this handler</li> <li>@return SyncHandlerComponent - The handler instance <p>This constructor implements a singleton pattern per handler name. If a handler with the given name already exists, it returns that instance instead of creating a new one. This is crucial for cross-script communication where different scripts need to access the same handler.</p>"},{"location":"Utils/SyncHandler/#component","title":"Component","text":""},{"location":"Utils/SyncHandler/#oninvoketself-synchandlercomponenttcallback-t-","title":"<code>OnInvoke&lt;T...&gt;(self : SyncHandlerComponent&lt;T...&gt;,callback : (T...) -&gt; ()) : () -&gt; ()</code>","text":"<p>Registers a callback function to handle invocations</p> <ul> <li>@param callback - The function that will process invocations and return results</li> <li>@return function - A cleanup function that disconnects the handler when called</li> </ul> <p>This method enforces single-handler behavior. If a handler is already registered, it returns a cleanup function for the existing handler without replacing it. The returned cleanup function provides a convenient way to disconnect the handler without needing to keep a reference to the handler object.</p>"},{"location":"Utils/SyncHandler/#invoketself-synchandlercomponentt-any","title":"<code>Invoke&lt;T...&gt;(self : SyncHandlerComponent&lt;T...&gt;,...) : ...any</code>","text":"<p>Invokes the handler with the provided arguments and waits for a response</p> <ul> <li>@param ... - Arguments to pass to the handler function</li> <li>@return ...any - The values returned by the handler, or nil if timeout occurs</li> </ul> <p>This method implements a timeout-protected invocation system. It attempts to invoke the handler and will wait up to the configured timeout duration for a response. If no response is received within the timeout, it returns nil and logs a warning.</p> <p>The implementation uses a polling approach with task.defer to prevent blocking while still providing synchronous-like behavior.</p>"},{"location":"Utils/SyncHandler/#settimeouttself-synchandlercomponentttimeout-number","title":"<code>SetTimeout&lt;T...&gt;(self : SyncHandlerComponent&lt;T...&gt;,timeout : number)</code>","text":"<p>Sets the timeout duration for invoke operations</p> <ul> <li>@param timeout - The new timeout duration in seconds</li> </ul> <p>This allows you to adjust how long Invoke will wait for a response before giving up. Shorter timeouts can prevent long waits but may cause legitimate operations to fail. Longer timeouts are more forgiving but can cause delays when handlers are unresponsive.</p>"},{"location":"Utils/SyncHandler/#destroytself-synchandlercomponentt","title":"<code>Destroy&lt;T...&gt;(self : SyncHandlerComponent&lt;T...&gt;) : ()</code>","text":"<p>Completely destroys the handler and cleans up all resources</p> <p>This method should be called when the handler is no longer needed. It:</p> <ol> <li>Disconnects any registered handler function</li> <li>Destroys the underlying BindableFunction</li> <li>Clears all internal references</li> <li>Removes metatable connections</li> </ol> <p>After calling Destroy(), this handler instance should not be used again.</p>"},{"location":"Utils/SyncHandler/#component-alias","title":"Component alias","text":"<pre><code>-- Method aliases for different naming conventions\n-- These provide flexibility for users with different coding style preferences\n\n-- Lowercase aliases\nSyncHandlerComponent.setTimeout = SyncHandlerComponent.SetTimeout\nSyncHandlerComponent.SetTimeOut = SyncHandlerComponent.SetTimeout  -- Alternative capitalization\nSyncHandlerComponent.onInvoke = SyncHandlerComponent.OnInvoke\nSyncHandlerComponent.invoke = SyncHandlerComponent.Invoke\nSyncHandlerComponent.destroy = SyncHandlerComponent.Destroy\n\n-- Constructor aliases for different naming preferences\nSyncHandlerConstructor.New = SyncHandlerConstructor.new      -- Capital 'N' variant\nSyncHandlerConstructor.from = SyncHandlerConstructor.new     -- Lowercase 'from' pattern\nSyncHandlerConstructor.From = SyncHandlerConstructor.new     -- Capitalized 'From' pattern\n</code></pre>"},{"location":"Utils/SyncSignal/","title":"SyncSignal","text":""},{"location":"Utils/SyncSignal/#overview","title":"Overview","text":"<p>A custom signal implementation that wraps Roblox's <code>BindableEvent</code> to provide a more controlled and feature-rich event system. This module ensures that only one callback can be connected to each signal at a time, making it ideal for synchronized operations where multiple listeners could cause conflicts.</p>"},{"location":"Utils/SyncSignal/#features","title":"Features","text":"<ul> <li>Single listener enforcement - Only one callback can be connected at a time</li> <li>Global registry system - Prevents duplicate signals with the same name</li> <li>Memory management - Proper cleanup methods included</li> <li>Type-safe generic implementation - Supports any number of arguments</li> <li>Familiar API - Similar to RBXScriptSignal</li> </ul>"},{"location":"Utils/SyncSignal/#installation-syncsignal","title":"Installation: SyncSignal","text":""},{"location":"Utils/SyncSignal/#quick-example","title":"Quick example","text":"Script 1Script 2 <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal openEvxEngine = ReplicatedStorage.OpenEvxEngine\n\nlocal SyncSignal = require(openEvxEngine.SyncSignal)\n\n--Build a new SyncSignal instance\nlocal build = SyncSignal.new(\"Build\")\n\n--connect the .Event of the BindableEvent\nbuild:Connect(function(...)\n    print(...) -- prints the arguments passed to the .Fire\nend)\n</code></pre> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal openEvxEngine = ReplicatedStorage.OpenEvxEngine\n\nlocal SyncSignal = require(openEvxEngine.SyncSignal)\n\n--Build a new SyncSignal instance\nlocal build = SyncSignal.new(\"Build\")\n\ntask.wait(1.5) -- wait a little bit to let the \"Script1\" script connect the bindable event\n\n--Fire with arguments (e.g a string)\nbuild:Fire(\"hello SyncSignal\") -- will print \"hello SyncSignal\" in the \"Script1\" script\n</code></pre>"},{"location":"Utils/SyncSignal/#api","title":"API","text":""},{"location":"Utils/SyncSignal/#constructor","title":"Constructor","text":""},{"location":"Utils/SyncSignal/#newt-syncsignalcomponentt","title":"<code>new&lt;T...&gt;() -&gt; SyncSignalComponent&lt;T...&gt;</code>","text":"<p>Creates a new SyncSignal instance or returns an existing one with the same name</p> <ul> <li>@param Name - A unique string identifier for this signal</li> <li>@return SyncSignalComponent - The signal instance <p>This constructor implements a singleton pattern per signal name, ensuring that multiple calls with the same name return the same signal instance. This is useful for cross-script communication where different scripts need to access the same signal.</p>"},{"location":"Utils/SyncSignal/#component","title":"Component","text":""},{"location":"Utils/SyncSignal/#connecttself-syncsignalcomponentt-callback-t-rbxscriptconnection","title":"<code>Connect&lt;T...&gt;(self : SyncSignalComponent&lt;T...&gt;, callback : (T...) -&gt; ()) -&gt; RBXScriptConnection</code>","text":"<p>Connects a callback function to this signal</p> <ul> <li>@param callback - The function to call when the signal is fired</li> <li>@return RBXScriptConnection - A connection object that can be used to disconnect</li> </ul> <p>Important: This method enforces single-listener behavior. If a callback is already connected, it returns the existing connection without replacing it. This prevents multiple listeners from being attached to the same signal, ensuring synchronized behavior.</p>"},{"location":"Utils/SyncSignal/#oncetself-syncsignalcomponentt-callback-t-","title":"<code>Once&lt;T...&gt;(self : SyncSignalComponent&lt;T...&gt;, callback : (T...) -&gt; ()) -&gt; ()</code>","text":"<p>Connects a callback that automatically disconnects after being fired once</p> <ul> <li>@param callback - The function to call when the signal is fired</li> </ul> <p>This is useful for scenarios where you only need to respond to an event once, such as waiting for initialization to complete or handling a one-time user action. The connection is automatically cleaned up after the first fire</p>"},{"location":"Utils/SyncSignal/#firetself-syncsignalcomponentt-","title":"<code>Fire&lt;T...&gt;(self : SyncSignalComponent&lt;T...&gt;,...) -&gt; ()</code>","text":"<p>Fires the signal with the provided arguments</p> <ul> <li>@param ... - Any number of arguments to pass to connected callbacks</li> </ul> <p>This method triggers all connected callbacks (though in this implementation, there can only be one). The arguments are passed through the underlying BindableEvent to any listening callbacks.</p>"},{"location":"Utils/SyncSignal/#waittself-syncsignalcomponentt-t","title":"<code>Wait&lt;T...&gt;(self : SyncSignalComponent&lt;T...&gt;) -&gt; T...</code>","text":"<p>Yields the current thread until the signal is fired</p> <ul> <li>@return T... - The arguments that were passed to Fire()</li> </ul> <p>This method is useful for synchronous code that needs to wait for an event to occur before continuing. It will pause execution until Fire() is called on this signal.</p>"},{"location":"Utils/SyncSignal/#disconnecttself-syncsignalcomponentt-","title":"<code>Disconnect&lt;T...&gt;(self : SyncSignalComponent&lt;T...&gt;) -&gt; ()</code>","text":"<p>Disconnects the current callback without destroying the signal</p> <p>This method removes the current listener but keeps the signal alive for future use. After calling this, a new callback can be connected to the signal.</p>"},{"location":"Utils/SyncSignal/#destroytself-syncsignalcomponentt-","title":"<code>Destroy&lt;T...&gt;(self : SyncSignalComponent&lt;T...&gt;) -&gt; ()</code>","text":"<p>Completely destroys the signal and cleans up all resources</p> <p>This method should be called when the signal is no longer needed. It:</p> <ol> <li>Disconnects any active connections</li> <li>Removes the signal from the global registry</li> <li>Destroys the underlying BindableEvent</li> <li>Clears all references to help garbage collection</li> </ol> <p>After calling Destroy(), this signal instance should not be used again.</p>"},{"location":"Utils/SyncSignal/#component-alias","title":"Component alias","text":"<pre><code>-- Method aliases for different naming conventions\n-- These provide flexibility in how users can call the methods\n\n-- Lowercase aliases for users who prefer lowercase method names\nSyncSignalComponent.destroy = SyncSignalComponent.Destroy\nSyncSignalComponent.disconnect = SyncSignalComponent.Disconnect\nSyncSignalComponent.fire = SyncSignalComponent.Fire\nSyncSignalComponent.wait = SyncSignalComponent.Wait\nSyncSignalComponent.connect = SyncSignalComponent.Connect\nSyncSignalComponent.once = SyncSignalComponent.Once\n\n-- Constructor aliases for different naming preferences\nSyncSignalConstructor.New = SyncSignalConstructor.new\n-- \"From\" aliases for a more semantic construction pattern\nSyncSignalConstructor.From = SyncSignalConstructor.new\nSyncSignalConstructor.from = SyncSignalConstructor.new\n</code></pre>"},{"location":"Utils/Task/","title":"Task","text":""},{"location":"Utils/Task/#installation-task","title":"Installation Task","text":"<p>This module handle Instance/Metatable/Connection with clean up function ex </p> <pre><code>    {\"Destroy\",\"Disconnect\",\"DisconnectAll\",\"DoCleaning\",\"Clean\"}\n</code></pre> <p>More clean up function can be set directly from the module itself</p>"},{"location":"Utils/Task/#getting-started","title":"Getting Started","text":"ConnectionInstanceClass <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\n\n--[[\n    Task.new() return a new TaskClass\n]]\nlocal TaskHandler = Task.new()\n\nTaskHandler:Add(workspace.Baseplate:GetPropertyChangedSignal(\"Position\"):Connect(function(...: any) \n    -- do stuff here\nend)) -- Connect the function to the handler\n\nTaskHandler:Destroy() -- Connection(s) will be disconnected\n</code></pre> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\n\n--[[\n    Task.new() return a new TaskClass\n]]\nlocal TaskHandler = Task.new()\n\nTaskHandler:Add(workspace.Baseplate) -- Attach the Baseplate to the task handler\n\nTaskHandler:Destroy() -- Baseplate will be destroyed\n</code></pre> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\n\n--Create a random strict class\nlocal class = {\n    Destroy = function()\n        print(\"Cleaning...\")\n    end,\n}\nsetmetatable(class,{\n    __index = function(t,k)\n        warn(`Can't get Class::{type(k)}`)\n    end,\n    __newindex = function(t,k,v)\n        warn(`Can't set Class:{type(k)} (not a valid member)`)\n    end,    \n})\n\n--[[\n    Task.new() return a new TaskClass\n]]\nlocal TaskHandler = Task.new()\n\nTaskHandler:Add(class) -- Added \"Class\" to the task handler\n\nTaskHandler:Destroy() -- Will print \"Cleaning...\"\n</code></pre> <p>Class without clean up function</p> <p>If you try to pass a class without a single clean up function the class will be discarded and not added to the task handler.</p>"},{"location":"Utils/Task/#using-signal","title":"Using Signal","text":"<p>Exemples:</p> <p>The used signal is the from sleitnick</p> <p>link: Signal Module</p> Code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\nlocal Signal = require(ReplicatedStorage.Signal)\n\nlocal TaskHandler = Task.new()\nlocal signal = Signal.new()\n\nTaskHandler:Add(signal:Connect(function(...)\n    print(...) -- Will print hello signal\nend))\n\nsignal:Fire(\"Hello Signal\")\n\nTaskHandler:Clean()\n\nsignal:Fire(\"Goodbye Signal\") -- This will never show\n</code></pre>"},{"location":"Utils/Task/#using-promise","title":"Using Promise","text":"<p>For promise you should prefer to use :AddPromise instead of Add</p> Code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\nlocal Promise = require(ReplicatedStorage.Promise)\n\nlocal TaskHandler = Task.new()\n\nTaskHandler:AddPromise(Promise.new(function(resolve,reject,onCancel) \n        -- Promise stuff here\nend))\n\nTaskHandler:Clean()\n</code></pre>"},{"location":"Utils/Task/#executing-function","title":"Executing function","text":"<p>The :Execute function allow you to directly call a function (only) instead of calling this function in the clean up state</p> Code <pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\n    local Task = require(ReplicatedStorage.Task)\n    local Promise = require(ReplicatedStorage.Promise)\n\n    local TaskHandler = Task.new()\n\n    TaskHandler:Add(function()\n        print(\"hi but on the clean up state\") -- print after :Clean()\n    end)\n\n    TaskHandler:Execute(function()\n        print(\"hi\") -- print instantly\n    end)\n\n    task.wait(1)\n\n    TaskHandler:Clean()\n</code></pre>"},{"location":"Utils/Task/#api","title":"API","text":""},{"location":"Utils/Task/#gettaskatindexindex-number","title":"GetTaskAtIndex(index : number)","text":"<p>You can get the added connection/class/instance/function from the target index</p> Code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\nlocal Promise = require(ReplicatedStorage.Promise)\n\nlocal TaskHandler = Task.new()\n\nTaskHandler:Add(function()\n    print(\"hi but on the clean up state\") -- print after :Clean()\nend)\n\nTaskHandler:GetTaskAtIndex(1)() -- print \"hi but on the clean up state\"\n\ntask.wait(1)\n\nTaskHandler:Clean()\n</code></pre> <p>Calling function with GetTaskAtIndex</p> <p>if you call a returned function from GetTaskAtIndex at the CleanUp state of Task the same function will be called</p>"},{"location":"Utils/Task/#istask","title":"IsTask()","text":"<p>Check if the current passed table is a task Class</p> Code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal Task = require(ReplicatedStorage.Task)\nlocal Promise = require(ReplicatedStorage.Promise)\n\nlocal TaskHandler = Task.new()\n\nprint(Task.IsTask(TaskHandler)) -- true\nprint(Task.IsTask({})) -- false\n</code></pre>"},{"location":"Utils/UserInput/","title":"UserInput","text":""},{"location":"Utils/UserInput/#overview","title":"Overview","text":"<p>The UserInput Component is a Roblox module that provides a unified interface for handling user input from both keyboard and gamepad devices. It abstracts the differences between input types and provides a consistent API with signal-based events.</p>"},{"location":"Utils/UserInput/#features","title":"Features","text":"<ul> <li>Dual Input Support: Seamlessly handle both Keyboard and Gamepad inputs</li> <li>Dynamic Switching: Change input types on the fly</li> <li>Key Registration: Filter which keys trigger events</li> <li>Signal-Based Events: Clean event system for key press/release</li> <li>Input Observation: Detect when users switch input methods</li> <li>Proper Cleanup: Built-in memory management</li> </ul>"},{"location":"Utils/UserInput/#installation-userinput","title":"Installation: UserInput","text":""},{"location":"Utils/UserInput/#api","title":"API","text":""},{"location":"Utils/UserInput/#constructor","title":"Constructor","text":""},{"location":"Utils/UserInput/#newconfig-userinputconfiguration-userinputcomponent","title":"<code>new(config: UserInputConfiguration): UserInputComponent</code>","text":"<p>Creates a new UserInput component instance.</p> <p>Parameters:</p> <p>config: Configuration object with the following properties:</p> <ul> <li>Keys: {Enum.KeyCode} - Array of keys to register</li> <li>InputType: \"Gamepad\" | \"Keyboard\" - Initial input type `</li> </ul>"},{"location":"Utils/UserInput/#component","title":"Component","text":""},{"location":"Utils/UserInput/#pressedself-userinputcomponentcallback-key-enumkeycode-signalconnectionstruct","title":"<code>Pressed(self : UserInputComponent,callback : (key : Enum.KeyCode) -&gt; ()) -&gt; SignalConnectionStruct</code>","text":"<p>Public method to connect a callback to the key pressed event</p> <ul> <li>@param callback: Function that will be called when a registered key is pressed</li> <li>@return: SignalConnection that can be used to disconnect the callback</li> </ul>"},{"location":"Utils/UserInput/#releasedself-userinputcomponentcallback-key-enumkeycode-signalconnectionstruct","title":"<code>Released(self : UserInputComponent,callback : (key : Enum.KeyCode) -&gt; ()) -&gt; SignalConnectionStruct</code>","text":"<p>Public method to connect a callback to the key released event</p> <ul> <li>@param callback: Function that will be called when a registered key is released</li> <li>@return: SignalConnection that can be used to disconnect the callback</li> </ul>"},{"location":"Utils/UserInput/#observeself-userinputcomponentcallback-inputtype-gamepad-mousekeyboard-touch-","title":"<code>Observe(self : UserInputComponent,callback : (InputType : \"Gamepad\" | \"MouseKeyboard\" | \"Touch\") -&gt; ()) : () -&gt; ()</code>","text":"<p>Observe changes in the user's preferred input method</p> <ul> <li>@param callback: Function called when input type changes (Gamepad, MouseKeyboard, or Touch)</li> <li>@return: Cleanup function to stop observing</li> </ul>"},{"location":"Utils/UserInput/#changeinputtypeself-userinputcomponentinputtype-gamepad-keyboard","title":"<code>ChangeInputType(self : UserInputComponent,InputType : \"Gamepad\" | \"Keyboard\")</code>","text":"<p>Dynamically change the input type between Gamepad and Keyboard This will clear all registered keys and recreate the input handlers</p> <ul> <li>@param InputType: Either \"Gamepad\" or \"Keyboard\"</li> </ul>"},{"location":"Utils/UserInput/#changekeyself-userinputcomponentkeys-enumkeycode","title":"<code>ChangeKey(self : UserInputComponent,Keys : {Enum.KeyCode})</code>","text":"<p>Replace all currently registered keys with a new set</p> <ul> <li>@param Keys: Array of KeyCodes to register</li> </ul>"},{"location":"Utils/UserInput/#addkeyself-userinputcomponentkeys-enumkeycode","title":"<code>AddKey(self : UserInputComponent,Keys : {Enum.KeyCode})</code>","text":"<p>Add new keys to the existing registered set Duplicate keys are automatically ignored</p> <ul> <li>@param Keys: Array of KeyCodes to add</li> </ul>"},{"location":"Utils/UserInput/#removekeyself-userinputcomponentkeys-enumkeycode","title":"<code>RemoveKey(self : UserInputComponent,Keys : {Enum.KeyCode})</code>","text":"<p>Remove specific keys from the registered set</p> <ul> <li>@param Keys: Array of KeyCodes to remove</li> </ul>"},{"location":"Utils/UserInput/#disconnectpressedself-userinputcomponent","title":"<code>DisconnectPressed(self : UserInputComponent)</code>","text":"<p>Disconnect all callbacks connected to the KeyPressed signal Useful for temporarily disabling key press detection</p>"},{"location":"Utils/UserInput/#disconnectreleasedself-userinputcomponent","title":"<code>DisconnectReleased(self : UserInputComponent)</code>","text":"<p>Disconnect all callbacks connected to the KeyReleased signal Useful for temporarily disabling key release detection</p>"},{"location":"Utils/UserInput/#destroyself-userinputcomponent","title":"<code>Destroy(self : UserInputComponent)</code>","text":"<p>Complete cleanup of the UserInput component This should be called when the component is no longer needed</p>"}]}